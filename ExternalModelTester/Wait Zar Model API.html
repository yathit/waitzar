<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>The Wait Zar model Application Programming Interface</title>

<style type="text/css">
	<!--
	h1{ 
	  color: #AAFFBB; 
	  font: 3em sans-serif;
	  margin: 12px 12px 12px 12px;
	} 
	a {
	  color:#00EEEE; 
	  text-decoration:none;
	}
	h2{ 
	  color: #AAFFBB; 
	  font: 1.5em monospace;
	  font-weight: bold;
	  margin: 12px 10px 10px 20px;
	} 
	h3{ 
	  color: #FFFFFF; 
	  font: 1.2em sans-serif;
	  font-weight: bold;
	} 
	* {
	  color: #FFFFFF;
	}
	.className {
	  color: #00EEEE;
	  font: 1.2em monospace;
	  font-weight: bold;
	}
	td {
	  border:1px solid #777777;
	}
	-->
</style>

</head>

<body bgcolor="#444444">


<table summary="" border="4" cellpadding="1" cellspacing="0" align="right" style="color:#000000;">
<tr>
<td  valign="top" align="right" bgcolor="white" style="color:#000000; border:2px solid blue;">
Style based off the&nbsp;
<br><em><b style="color:#000000;">Java<sup><font size="-2" style="color: #000000;">TM</font></sup>&nbsp;Platform&nbsp;
<br>&nbsp;<a href="http://java.sun.com/j2se/1.5.0/docs/api/" style="color:#0066FF; text-decoration:none;">API Documentation</a>&nbsp;</b></em>
</td>
</tr>
</table>

<h1>The Wait Zar Model</h1>
<h2>Application Programming Interface</h2>
<hr>

<h3>Introduction</h3>
The Wait Zar Model code, particularly that of WordBuilder.cpp, exists to help independent developers add Wait Zar's typing functionality into their developments. In general, Wait Zar is applicable to any programming task. However, there are certain situations where the hotkeys Wait Zar installs are simply sub-optimal (and this API is more useful). Here are some examples:
<ul>
    <li>You are working in Linux, and Wine doesn't work (or, you want something officially supported). A SCIM plugin is currently being developed independently, using this library.</li>
	<li>You are playing a game like Counterstrike, where typing is secondary to other actions (movement, aiming, etc.) and you need a different input model.</li>
	<li>Certain programs cause Wait Zar to constantly refresh (e.g., webcam conversations in MSN) which is something it does slowly. You are the developer for one of these programs, and you want to integrate Wait Zar directly into your program's interface.</li>
	<li>You are doing research into Natural Language processing. You want to test Wait Zar's accuracy in a series of batch operations, which you clearly don't want to have to key in by hand.</li>
</ul>

<h3>Why Use the Wait Zar API?</h3>
The key benefit of using this library is that its internal components will almost never change. You can basically just update the latest version of Myanmar.model (from the SVN) and run your program: no re-compiling necessary. In the case of bug fixes and the rare feature enhancement, just download the five or six code files from the SVN repository and re-compile --if there's a problem, rollback to the latest release builds, which we test thoroughly on both Windows and Linux.
<br>The file mywords.txt is also very "plugable". You can drop in a friend's custom word list, or email your own list to friends. Again, no recompiling is necessary.
<br>This gives you amazing amount of flexibility, coupled with cross-platform accuracy. Any application developed with this library will respond in the same way on any system. For example, a chat client developer can benefit from the stability of the Wait Zar romanisation (tested and approved by a large community of users, as of version 1.6) and also allow the chatters to add their own words to the dictionary, effecting system-wide enabling of these new words. But enough talk, let's see how it works!

<br>&nbsp;<hr>

<h3>Sample Code</h3>
Please see below for documentation of each method in WordBuilder.cpp. For now, we will explain how to load a model and run some queries on it. ExternalModelTester.cpp contains several good examples.

<br><br><b style="font: 1.0em sans-serif; font-weight:bold;">Listing Entries for a Word</b>
<br>Given a romanised Burmese word, like "kote", we might want to list all the Burmese words which can be typed this way. The steps for doing this are simple:
<br><br><code>model-&gt;reset(true);
<br>model-&gt;typeLetter('k');
<br>model-&gt;typeLetter('o');
<br>model-&gt;typeLetter('t');
<br>model-&gt;typeLetter('e');
<br>std::vector&lt;unsigned int&gt; possWords = model-&gt;getPossibleWords();
<br></code>
<br>At this point, "possWords" contains the IDs of all the Myanmar words we can type. In general, the Wait Zar model uses a word's abstract id for all comparisons and storage-related tasks (rather than, say, strings). This id is assigned based on the word's position in Myanmar.model; it changes whenever the Myanmar.model file changes. Words contained in mywords.txt are assigned IDs as well, up to a maximum number.

<br><br><b style="font: 1.0em sans-serif; font-weight:bold;">Showing or Typing a Word</b>
<br>When a Burmese word is shown <em>within</em> Wait Zar, it is shown using the Zawgyi-One encoding. Thus, calling model->getWordString() will return a wchar_t* encoded according to the rules of the Zawgyi-One specification. This will happen <strong>regardless</strong> of the model's current encoding! Getting a string in the encoding of your choice is somewhat tricky: the easiest way to do it as of now is to call getWordKeyStrokes() and then construct the wide-character string on your own. Here's an example of how to get the Win Innwa-encoded string for the first (and only) "kote" 
<br><br><code>model-&gt;setOutputEncoding(ENCODING_WININNWA);
<br>std::vector&lt;unsigned short&gt; currWord = model-&gt;getWordKeyStrokes(possWords[i]);
<br>wchar_t* printWord[1000];
<br>for (unsigned int i=0; i&lt;keystrokes.size(); i++) {
<br>&nbsp;&nbsp;printWord[i] = keystrokes[i];
<br>}
<br>//Note: we need to terminate with a FULL-width zero (not just '\0') to ensure that we actually end the string.
<br>printWord[keystrokes.size()] = 0x0000; 
<br>wprintf(L"  %ls  (", printWord);
<br></code>
<br>Actually, the call to wprintf() is somewhat risky; for one thing, you can't mix calls to printf() with those for wprintf() in the same console application (which makes using library code a tedious task). For another thing, the standard Unix console won't print Unicode characters by default, and enabling Unicode isn't always easy. (For this case, because Win Innwa is being used, this particular effect is not noticeable.) Regardless, if you iterated through printWord's wchar_t elements, you would see that their values are correct. 



<h2>more later</h2>


<br>&nbsp;<hr>

<h3>Method Summary </h3>

<!-- Table header -->
<table summary="" width="100%" border="1" cellpadding="3" cellspacing="0" style="border:2px solid #999999;"><tbody>
<tr bgcolor="#AAFFBB">
<th colspan="2" align="left" style="border:1px solid #00CC00;">
<b style="font: 1.0em sans-serif; font-weight:bold; color: #000000;">WordBuilder.cpp</b></th>
</tr>

<!-- Elements -->

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>&nbsp;</code></font></td>
<td><code><b class="className">WordBuilder</b>(wchar_t* modelFile, wchar_t* userWordsFile)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Constructs a new WordBuilder object from a given model file and an (optional) list of user-defined words. Most developers will prefer this constructor.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>&nbsp;</code></font></td>
<td><code><b class="className">WordBuilder</b>(unsigned short **dictionary, int dictMaxID, int dictMaxSize, unsigned int **nexus, int nexusMaxID, int nexusMaxSize, unsigned int **prefix, int prefixMaxID, int prefixMaxSize)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Constructs a new WordBuilder object gvien a detailed specification of its inner workings. Most developers will never need to use this constructor.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>&nbsp;</code></font></td>
<td><code><b class="className">~WordBuilder</b>(void)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Destructor. It is highly recommended that you do not rely on this method to release all memory used by WordBuilder; this hasn't actually been tested yet. As a singleton, however, WordBuilder has no known memory leaks. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">typeLetter</b>(char letter)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Types a letter and updates the available word/letter list appropriately. Please pay attention to getParenString() when using this function.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::pair&lt;bool, unsigned int&gt;&nbsp;</code></font></td>
<td><code><b class="className">typeSpace</b>(int quickJumpID)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Selects the current candidate word based on calls to moveRight() and returns its ID. A boolean value indicates if any word was selected at all.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">backspace</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Deletes one letter and moves the current nexus back one; returns false if there are no letters to delete.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>void&nbsp;</code></font></td>
<td><code><b class="className">reset</b>(bool fullReset)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Resets the current romanisation attempt. If "fullReset" is true, it also removes any captured trigrams. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">moveRight</b>(int amt)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Moves the cursor right "amt" spaces, if possible ("amt" can be negative). Returns false if "amt" number of moves could not be made, or if amt is zero.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>int&nbsp;</code></font></td>
<td><code><b class="className">getCurrSelectedID</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Gets the index of the current selected item. Returns -1 if there are no items to select.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::vector&lt;char&gt;&nbsp;</code></font></td>
<td><code><b class="className">getPossibleChars</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns all valid moves forward from this point. The prototype of WaitZar uses this, but the release version does not. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::vector &lt;unsigned int&gt;&nbsp;</code></font></td>
<td><code><b class="className">getPossibleWords</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns the IDs of all possible words at this point. Call getWordString() on each ID to retrieve the Zawgyi-One encoded string for each word. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>void&nbsp;</code></font></td>
<td><code><b class="className">insertTrigram</b>(unsigned short* trigram_ids, int num_used_trigrams)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Re-writes the current accumulated trigram (see method detail, below.) 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>wchar_t*</code></font></td>
<td><code><b class="className">getWordString</b>(unsigned int id)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns the wide-character string for a Myanmar word (in Zawgyi-One encoding) for a given ID. Note that the wchar_t pointer is shared; multiple calls to this function should use strcpy() to copy the returned value locally, lest all returned values default to that of the final string (see method detail, below.) 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::vector &lt;unsigned short&gt;&nbsp;</code></font></td>
<td><code><b class="className">getWordKeyStrokes</b>(unsigned int id)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For a given id, returns the key strokes required to type that word. Technically similar to getWordString(), but the vector of unsigned short values allows Wait Zar to pass each item to SendInput() fairly cleanly. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>wchar_t*&nbsp;</code></font></td>
<td><code><b class="className">getParenString</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Consider a word in the model, like "singapore". After typing "singap", there are no options reachable from this point except "ore". Calling getParenString() at this point will return this. On the contrary, after typing "k", getParenString() will return "" (empty string) --there are multiple options at this point. By default, if getPossibleWords() returns nothing, WaitZar will then check if getParenString() returns anything; if so, typing space will enter this word. This speeds up typing in general.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>unsigned short&nbsp;</code></font></td>
<td><code><b class="className">getStopCharacter</b>(bool isFull)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For isFull==true, returns the full stop character for this encoding; if isFull==false, returns the half stop character. See also: getOutputEncoding().
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">addRomanization</b>(wchar_t* myanmar, char* roman)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Adds a given "myanmar" word (encoded according to the Zawgyi-One specification), and its relative "roman"isation to the model. Returns an indication of success; see also: getLastError().
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>wchar_t*&nbsp;</code></font></td>
<td><code><b class="className">getLastError</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For any function that may fail with a specific error (for now, only "addRomanization()"), returns the text of that error message. Presumably, one would present the user with this information. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>void&nbsp;</code></font></td>
<td><code><b class="className">setOutputEncoding</b>(unsigned int encoding)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sets the output encoding for this model to one of the following: ENCODING_UNICODE, ENCODING_ZAWGYI, ENCODING_WININNWA. Note that ENCODING_UNICODE refers to the Unicode standard version 5.1+ (e.g., PadaukOT, Parabaik, Myanmar3). These constants are defined in WordBuilder.h
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>unsigned int&nbsp;</code></font></td>
<td><code><b class="className">getOutputEncoding</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns the output encoding set by the user (see: setOutputEncoding()). Defaults to ENCODING_UNICODE.
</td>
</tr>

</tbody></table>



<br>&nbsp;<hr>

<h3>Methods in Detail </h3>

<!-- Table header -->
<table summary="" width="100%" border="1" cellpadding="3" cellspacing="0" style="border:2px solid #999999;"><tbody>
<tr bgcolor="#AAFFBB">
<th colspan="2" align="left" style="border:1px solid #00CC00;">
<b style="font: 1.0em sans-serif; font-weight:bold; color: #000000;">WordBuilder.cpp</b></th>
</tr>
</tbody></table>

<!-- Elements -->

<h3>WordBuilder</h3>
<pre>WordBuilder::<b class="className">WordBuilder</b>(wchar_t* modelFile, wchar_t* userWordsFile)</pre>
<dl><dd>Constructs a WordBuilder object. Most developers will prefer this constructor.
</dl></dd>
<dd><dl>
<dt><b>Parameters:</b></dt>
<dd><code>modelFile</code> - Path to "Myanmar.model", a file that describes the Wait Zar model. <a href="http://waitzar.googlecode.com/svn/trunk/win32_source/Myanmar.model">Download a copy from the SVN.</a></dd>
<dd><code>userWordsFile</code> - Path to "mywords.txt", an (optional) UTF-8-encoded file specifying additional user romanisations --one per line-- of the form "myanmar = roman".</dd>
<!--dt><b>Returns:</b></dt><dd>nothing</dd-->
</dl>
</dd>
</dl>
<hr>




<h2>More later </h2>


<!-- Footer -->
<br>&nbsp;<br>&nbsp;<br>&nbsp;
<p><font size="-1">Copyright 2008 by Seth N. Hetu. Released under the Apache License, version 2.0. Please read the <a href="http://waitzar.googlecode.com/svn/trunk/LICENSE">License</a> and <a href="http://waitzar.googlecode.com/svn/trunk/NOTICE">Notice</a> files before copying this document.</font></p>

<!-- HTML end -->
</body>
</html>
